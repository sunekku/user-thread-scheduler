# user-thread-scheduler

Primitive preemptive user-level thread framework that enables thread creation and deletion. 
Other utilities allow sychronization (condition variables) and mutual exclusion (mutex locks).
For Linux systems. Main thread must use **thread_init()** to initialize system. Other threads begin
execution from within a stub function and call **thread_exit()** from within as well. File containing main() should be entitled **main.c**, 
and corresponding header should be entitled **main.h** for *make* to produce a *main* executable. Enter *make clean* to remove intermediary
files generated by the *make* command.

**NOTE:** Don't call thread_exit() on the main thread. Not only does it make no sense to do that on a kernel thread, but also you'll probably blow the program by placing 
main in the kill queue, whereafter some function will unsuccessfully try to deallocate memory for something in the data segment with free(). I didn't try it but I'm pretty sure that's what'd happen.

Occasionally drew inspiration from existing frameworks for this one, but it was such a headache to figure out
that I might as well take all the credit. Nobody does anything new from scratch unless they're being
paid.
